namespace UseBackingField;

using System.Runtime.InteropServices.ComTypes;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
public sealed class GenerateBackingFieldsAttribute() : Attribute
{
}

[AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
public sealed class BackingFieldNameAttribute(string fieldName) : Attribute
{
    public string FieldName { get; set; } = fieldName;

    internal static string? GetFieldName(AttributeData? attributeData) =>
    attributeData switch
    {
        { ConstructorArguments: { IsEmpty: false } and var args } => args[0].Value as string,
        { NamedArguments: { IsEmpty: false } and var args } => args.FirstOrDefault(arg => arg.Key == "FieldName").Value.Value as string,
        _ => null,
    };
}

[AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
public sealed class ExludeFromBackingFieldAttribute : Attribute
{
}

internal readonly record struct Property(string Name, string Type, string BackingFieldName)
{
    public static Property FromSyntax(IPropertySymbol property)
    {
        var type = property.Type.ToDisplayString();
        var name = property.Name;

        var backingFieldNameAttribute = property.GetAttributes().FirstOrDefault(attr => attr.AttributeClass?.Name == "BackingFieldNameAttribute");
        var backingFieldName = BackingFieldNameAttribute.GetFieldName(backingFieldNameAttribute) ?? $"__{name.ToLowerInvariant()}";

        return new Property(name, type, backingFieldName);
    }
}

internal readonly record struct ClassToGenerate(
    string Name,
    string Namespace,
    Accessibility Accessibility,
    EquatableArray<Property> Properties)
{
    public static ClassToGenerate? FromContext(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol namedTypeSymbol) { return null; }

        var properties = namedTypeSymbol.GetMembers().OfType<IPropertySymbol>()
            .Where(property => !property.GetAttributes().Any(attr => attr.AttributeClass?.Name == "ExludeFromBackingFieldAttribute"))
            .Select(Property.FromSyntax)
            .ToEquatableArray();

        return new ClassToGenerate(
            namedTypeSymbol.Name,
            namedTypeSymbol.ContainingNamespace.ToDisplayString(),
            namedTypeSymbol.DeclaredAccessibility,
            properties);
    }
}

[Generator]
public class BackingFieldsGenerator : IIncrementalGenerator
{
    public static readonly string FullyQualifiedAttributeName = $"{nameof(UseBackingField)}.{nameof(GenerateBackingFieldsAttribute)}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get the classes with the attribute
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                FullyQualifiedAttributeName,
                NodePredicate,
                transform: static (ctx, _) => ClassToGenerate.FromContext(ctx)
            );

        context.RegisterSourceOutput(classDeclarations, Execute);
    }

    private static void Execute(SourceProductionContext context, ClassToGenerate? classToGenerate)
    {
        if (classToGenerate is not { } value) { return; }

        var sb = new StringBuilder();
        sb.AppendLine($$"""
        /// <auto-generated />

        namespace {{value.Namespace}};

        {{value.Accessibility}} partial class {{value.Name}}
        {
        """);

        foreach (var property in value.Properties)
        {
            sb.AppendLine($"\t private {property.Type} {property.BackingFieldName};");
        }

        sb.AppendLine("}");
        
        context.AddSource($"{value.Name}_backingfields.g.cs", sb.ToString());
    }

    private static bool NodePredicate(SyntaxNode node, CancellationToken ct) =>
        // Filter out interfaces and types with no members, and types with no properties.
        node is TypeDeclarationSyntax { Members: { Count: > 0 } and var members } and not InterfaceDeclarationSyntax
        && members.Any(SyntaxKind.PropertyDeclaration);
}